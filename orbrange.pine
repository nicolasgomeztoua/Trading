//@version=5
strategy("Three-Step 9:30 Range Scalping (Backtest)", overlay=true, calc_on_every_tick=false, process_orders_on_close=true,
     initial_capital=50000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding=0)

// -------------------- Inputs
enableBreak    = input.bool(true,  "Enable Break Entry")
enableTrap     = input.bool(true, "Enable Trap Entry")
enableReversal = input.bool(true, "Enable Reversal Entry")
rr             = input.float(2.0,  "Take-Profit R Multiple", step=0.25, minval=0.25)
oneTradePerDay = input.bool(true,  "One Trade Per Day")
showRange      = input.bool(true,  "Show 9:30 5m Range")
showSL         = input.bool(true,  "Show Stop Loss Line")
showTP         = input.bool(true,  "Show Take Profit Line")
enableAlerts   = input.bool(true,  "Enable Alerts")

// Risk management
riskPct        = input.float(1.5,  "Risk % of Equity per Trade", step=0.1, minval=0.1, maxval=100.0)
sizeMode       = input.string("Risk %", "Position Sizing Mode", options=["Risk %", "Fixed contracts"])
fixedContracts = input.int(1, "Fixed Contracts", minval=1)

// Global minimum stop configuration (applies to all setups)
globalEnforceMinSL = input.bool(true, "Global: Enforce Minimum Stop (all setups)")
globalMinSLPoints  = input.float(40.0, "Global: Minimum Stop Distance (price units)", step=0.25, minval=0)
globalMinSLMode    = input.string("Pad to minimum", "Global: Handling if SL < minimum", options=["Pad to minimum", "Skip trade"])

// Optional: warn if not on 1-minute chart (execution timeframe per PRD)
onOneMinute = timeframe.isminutes and timeframe.multiplier == 1

// Utility formatter matching instrument min tick
fmt(v) => str.tostring(v, format.mintick)

// -------------------- Time helpers (chart is assumed New York time)
newDay   = ta.change(time("D")) != 0
// Trade the first hour only: 9:30:00 to 10:29:59
inWindow = (hour == 9 and minute >= 30) or (hour == 10 and minute <= 29)
// Holiday blackout window: Do not trade Dec 15 – Jan 15
inBlackout = (month == 12 and dayofmonth >= 15) or (month == 1 and dayofmonth <= 15)

// -------------------- First 5-min range (use the actual 9:30 5m candle via security())
var float rangeHi = na
var float rangeLo = na
var bool  haveRange = false

// -------------------- State for entries
var bool  breakUpFound           = false
var bool  breakDownFound         = false
var float initBreakUpLow         = na    // for Break/Trap long SL
var float initBreakDownHigh      = na    // for Break/Trap short SL
var bool  trapUpRetestedInside   = false
var bool  trapDownRetestedInside = false
var bool  tradedToday            = false
// Prevent multiple TRAP entries from the same break/retest sequence
var bool  trapUpConsumed         = false
var bool  trapDownConsumed       = false
// Active TP/SL levels for plotting
var float activeSL = na
var float activeTP = na
// Prevent multiple BREAK entries per direction per day
var bool  breakLongConsumed      = false
var bool  breakShortConsumed     = false
// Prevent multiple REVERSAL entries per direction per day
var bool  revLongConsumed        = false
var bool  revShortConsumed       = false

// Reset daily state at midnight (chart timezone)
if newDay
    rangeHi := na
    rangeLo := na
    haveRange := false
    breakUpFound := false
    breakDownFound := false
    initBreakUpLow := na
    initBreakDownHigh := na
    trapUpRetestedInside := false
    trapDownRetestedInside := false
    tradedToday := false
    trapUpConsumed := false
    trapDownConsumed := false
    activeSL := na
    activeTP := na
    breakLongConsumed := false
    breakShortConsumed := false
    revLongConsumed := false
    revShortConsumed := false

// Pull the 5-minute bar that STARTS at 9:30 (value available on its close at 9:35)
sess0930Hi = request.security(syminfo.tickerid, "5", (hour == 9 and minute == 30) ? high : na, barmerge.gaps_off, barmerge.lookahead_off)
sess0930Lo = request.security(syminfo.tickerid, "5", (hour == 9 and minute == 30) ? low  : na, barmerge.gaps_off, barmerge.lookahead_off)

// Lock the range when the 9:30 5m candle closes (value appears non-na exactly then)
if not haveRange and not na(sess0930Hi) and not na(sess0930Lo)
    rangeHi := sess0930Hi
    rangeLo := sess0930Lo
    haveRange := true
    // reset session-specific flags at start of trading window
    breakUpFound := false
    breakDownFound := false
    initBreakUpLow := na
    initBreakDownHigh := na
    trapUpRetestedInside := false
    trapDownRetestedInside := false
    tradedToday := false
    trapUpConsumed := false
    trapDownConsumed := false
    activeSL := na
    activeTP := na
    breakLongConsumed := false
    breakShortConsumed := false
    revLongConsumed := false
    revShortConsumed := false

// -------------------- Visuals
plot(showRange and haveRange ? rangeHi : na, "Range High", color=color.new(color.teal, 0), style=plot.style_linebr, linewidth=2)
plot(showRange and haveRange ? rangeLo : na, "Range Low",  color=color.new(color.orange, 0), style=plot.style_linebr, linewidth=2)

plotchar(not onOneMinute, title="Use 1-minute chart", char="⚠", location=location.top, color=color.new(color.red, 0), size=size.tiny)
plotchar(inBlackout, title="Holiday blackout (Dec 15–Jan 15)", char="⛔", location=location.top, color=color.new(color.red, 0), size=size.tiny)

// -------------------- Convenience conditions
closeAbove  = haveRange and close > rangeHi
closeBelow  = haveRange and close < rangeLo
closeInside = haveRange and close <= rangeHi and close >= rangeLo

// Track first body-close outside the range in each direction (initial break-close)
if haveRange and inWindow and not tradedToday
    if not breakUpFound and closeAbove
        breakUpFound := true
        initBreakUpLow := low
        trapUpRetestedInside := false
        // re-arm long trap on a fresh break
        trapUpConsumed := false
    if not breakDownFound and closeBelow
        breakDownFound := true
        initBreakDownHigh := high
        trapDownRetestedInside := false
        // re-arm short trap on a fresh break
        trapDownConsumed := false

// Trap retest flags (retest back inside after first break)
if haveRange and inWindow and not tradedToday
    if breakUpFound and not trapUpRetestedInside and closeInside
        trapUpRetestedInside := true
    if breakDownFound and not trapDownRetestedInside and closeInside
        trapDownRetestedInside := true

// -------------------- FVG detectors (three-candle imbalance)
// Simple wick-gap definition, preserved through the third candle
// Bullish: gap exists if Candle C low > Candle A high AND Candle B low > Candle A high
// Bearish: gap exists if Candle C high < Candle A low  AND Candle B high < Candle A low
bullFVG = not na(high[2]) and (low[1] > high[2]) and (low > high[2])
bearFVG = not na(low[2])  and (high[1] < low[2])  and (high < low[2])

// -------------------- Entry gating
allowEntry = haveRange and inWindow and not inBlackout and strategy.position_size == 0 and (not oneTradePerDay or not tradedToday)

// Calculate contracts based on selected sizing mode
calcOrderQty(entryPrice, stopPrice) =>
    qty = 0
    if sizeMode == "Fixed contracts"
        qty := fixedContracts
    else
        riskCash = strategy.equity * riskPct / 100.0
        riskPerContract = math.abs(entryPrice - stopPrice) * syminfo.pointvalue
        qty := riskPerContract > 0 ? math.floor(riskCash / riskPerContract) : 0
    qty

// -------------------- BREAK Entries (needs FVG and ANY of the 3 bars closes outside)
if enableBreak and allowEntry
    // Long BREAK
    breakLongOk  = bullFVG and (close > rangeHi or close[1] > rangeHi or close[2] > rangeHi) and not breakLongConsumed
    if breakLongOk
        // Stop at the very first 1m candle that closed outside the range (initial break)
        float stopL = na
        stopL := na(initBreakUpLow) ? low : initBreakUpLow
        entryL = close
        bool skipTradeL = false
        // Global minimum stop enforcement (all setups)
        if globalEnforceMinSL
            minRisk = globalMinSLPoints
            currRisk = entryL - stopL
            if currRisk < minRisk
                if globalMinSLMode == "Pad to minimum"
                    stopL := entryL - minRisk
                else
                    skipTradeL := true
        if not skipTradeL and entryL > stopL
            tpL = entryL + rr * (entryL - stopL)
            qtyL = calcOrderQty(entryL, stopL)
            if qtyL > 0
                strategy.entry("LONG_BREAK", strategy.long, qty=qtyL)
                strategy.exit("LONG_BREAK_TP/SL", from_entry="LONG_BREAK", stop=stopL, limit=tpL)
                activeSL := stopL
                activeTP := tpL
                tradedToday := oneTradePerDay ? true : tradedToday
                breakLongConsumed := true
                if enableAlerts
                    riskPts = entryL - stopL
                    tpPts   = tpL - entryL
                    alert(str.format("{0} LONG_BREAK entry={1} stop={2} tp={3} riskPts={4} tpPts={5}", syminfo.ticker, fmt(entryL), fmt(stopL), fmt(tpL), fmt(riskPts), fmt(tpPts)), alert.freq_once_per_bar_close)
    // Short BREAK
    breakShortOk = bearFVG and (close < rangeLo or close[1] < rangeLo or close[2] < rangeLo) and not breakShortConsumed
    if breakShortOk
        // Stop at the very first 1m candle that closed outside the range (initial break)
        float stopS = na
        stopS := na(initBreakDownHigh) ? high : initBreakDownHigh
        entryS = close
        bool skipTradeS = false
        // Global minimum stop enforcement (all setups)
        if globalEnforceMinSL
            minRiskS = globalMinSLPoints
            currRiskS = stopS - entryS
            if currRiskS < minRiskS
                if globalMinSLMode == "Pad to minimum"
                    stopS := entryS + minRiskS
                else
                    skipTradeS := true
        if not skipTradeS and entryS < stopS
            tpS = entryS - rr * (stopS - entryS)
            qtyS = calcOrderQty(entryS, stopS)
            if qtyS > 0
                strategy.entry("SHORT_BREAK", strategy.short, qty=qtyS)
                strategy.exit("SHORT_BREAK_TP/SL", from_entry="SHORT_BREAK", stop=stopS, limit=tpS)
                activeSL := stopS
                activeTP := tpS
                tradedToday := oneTradePerDay ? true : tradedToday
                breakShortConsumed := true
                if enableAlerts
                    riskPts = stopS - entryS
                    tpPts   = entryS - tpS
                    alert(str.format("{0} SHORT_BREAK entry={1} stop={2} tp={3} riskPts={4} tpPts={5}", syminfo.ticker, fmt(entryS), fmt(stopS), fmt(tpS), fmt(riskPts), fmt(tpPts)), alert.freq_once_per_bar_close)

// -------------------- TRAP Entries (Break → Retest inside → Reclose outside; FVG not required)
if enableTrap and allowEntry
    // Long TRAP
    if breakUpFound and trapUpRetestedInside and closeAbove and not trapUpConsumed
        baseStopL  = na(initBreakUpLow) ? low : initBreakUpLow
        entryL = close
        float stopL = baseStopL
        bool skipTradeL = false
        // Apply global minimum stop as well
        if globalEnforceMinSL and not skipTradeL
            minRiskG = globalMinSLPoints
            currRiskG = entryL - stopL
            if currRiskG < minRiskG
                if globalMinSLMode == "Pad to minimum"
                    stopL := entryL - minRiskG
                else
                    skipTradeL := true
        if not skipTradeL and entryL > stopL
            tpL = entryL + rr * (entryL - stopL)
            qtyL = calcOrderQty(entryL, stopL)
            if qtyL > 0
                strategy.entry("LONG_TRAP", strategy.long, qty=qtyL)
                strategy.exit("LONG_TRAP_TP/SL", from_entry="LONG_TRAP", stop=stopL, limit=tpL)
                activeSL := stopL
                activeTP := tpL
                tradedToday := oneTradePerDay ? true : tradedToday
                trapUpConsumed := true
                // Disarm until a fresh retest back inside occurs
                trapUpRetestedInside := false
                if enableAlerts
                    riskPts = entryL - stopL
                    tpPts   = tpL - entryL
                    alert(str.format("{0} LONG_TRAP entry={1} stop={2} tp={3} riskPts={4} tpPts={5}", syminfo.ticker, fmt(entryL), fmt(stopL), fmt(tpL), fmt(riskPts), fmt(tpPts)), alert.freq_once_per_bar_close)
    // Short TRAP
    if breakDownFound and trapDownRetestedInside and closeBelow and not trapDownConsumed
        baseStopS  = na(initBreakDownHigh) ? high : initBreakDownHigh
        entryS = close
        float stopS = baseStopS
        bool skipTradeS = false
        // Apply global minimum stop as well
        if globalEnforceMinSL and not skipTradeS
            minRiskGS = globalMinSLPoints
            currRiskGS = stopS - entryS
            if currRiskGS < minRiskGS
                if globalMinSLMode == "Pad to minimum"
                    stopS := entryS + minRiskGS
                else
                    skipTradeS := true
        if not skipTradeS and entryS < stopS
            tpS = entryS - rr * (stopS - entryS)
            qtyS = calcOrderQty(entryS, stopS)
            if qtyS > 0
                strategy.entry("SHORT_TRAP", strategy.short, qty=qtyS)
                strategy.exit("SHORT_TRAP_TP/SL", from_entry="SHORT_TRAP", stop=stopS, limit=tpS)
                activeSL := stopS
                activeTP := tpS
                tradedToday := oneTradePerDay ? true : tradedToday
                trapDownConsumed := true
                // Disarm until a fresh retest back inside occurs
                trapDownRetestedInside := false
                if enableAlerts
                    riskPts = stopS - entryS
                    tpPts   = entryS - tpS
                    alert(str.format("{0} SHORT_TRAP entry={1} stop={2} tp={3} riskPts={4} tpPts={5}", syminfo.ticker, fmt(entryS), fmt(stopS), fmt(tpS), fmt(riskPts), fmt(tpPts)), alert.freq_once_per_bar_close)

// -------------------- REVERSAL Entries (Failed break + opposite FVG back into range)
if enableReversal and allowEntry
    // After bearish break, bullish FVG back into range → LONG
    if breakDownFound and bullFVG and closeInside and not revLongConsumed
        stopL  = low[2]  // first candle of the FVG
        entryL = close
        bool skipRevL = false
        if globalEnforceMinSL
            minRisk = globalMinSLPoints
            currRisk = entryL - stopL
            if currRisk < minRisk
                if globalMinSLMode == "Pad to minimum"
                    stopL := entryL - minRisk
                else
                    skipRevL := true
        if not skipRevL and entryL > stopL
            tpL = entryL + rr * (entryL - stopL)
            qtyL = calcOrderQty(entryL, stopL)
            if qtyL > 0
                strategy.entry("LONG_REV", strategy.long, qty=qtyL)
                strategy.exit("LONG_REV_TP/SL", from_entry="LONG_REV", stop=stopL, limit=tpL)
                revLongConsumed := true
                activeSL := stopL
                activeTP := tpL
                tradedToday := oneTradePerDay ? true : tradedToday
                if enableAlerts
                    riskPts = entryL - stopL
                    tpPts   = tpL - entryL
                    alert(str.format("{0} LONG_REV entry={1} stop={2} tp={3} riskPts={4} tpPts={5}", syminfo.ticker, fmt(entryL), fmt(stopL), fmt(tpL), fmt(riskPts), fmt(tpPts)), alert.freq_once_per_bar_close)
    // After bullish break, bearish FVG back into range → SHORT
    if breakUpFound and bearFVG and closeInside and not revShortConsumed
        stopS  = high[2] // first candle of the FVG
        entryS = close
        bool skipRevS = false
        if globalEnforceMinSL
            minRiskS = globalMinSLPoints
            currRiskS = stopS - entryS
            if currRiskS < minRiskS
                if globalMinSLMode == "Pad to minimum"
                    stopS := entryS + minRiskS
                else
                    skipRevS := true
        if not skipRevS and entryS < stopS
            tpS = entryS - rr * (stopS - entryS)
            qtyS = calcOrderQty(entryS, stopS)
            if qtyS > 0
                strategy.entry("SHORT_REV", strategy.short, qty=qtyS)
                strategy.exit("SHORT_REV_TP/SL", from_entry="SHORT_REV", stop=stopS, limit=tpS)
                revShortConsumed := true
                activeSL := stopS
                activeTP := tpS
                tradedToday := oneTradePerDay ? true : tradedToday
                if enableAlerts
                    riskPts = stopS - entryS
                    tpPts   = entryS - tpS
                    alert(str.format("{0} SHORT_REV entry={1} stop={2} tp={3} riskPts={4} tpPts={5}", syminfo.ticker, fmt(entryS), fmt(stopS), fmt(tpS), fmt(riskPts), fmt(tpPts)), alert.freq_once_per_bar_close)

// -------------------- Markers
plotshape(enableBreak and (bullFVG and (close > rangeHi or close[1] > rangeHi or close[2] > rangeHi)) and allowEntry and not breakLongConsumed,  title="Break Long",  style=shape.triangleup,   color=color.new(color.teal, 0),   size=size.tiny, location=location.belowbar, text="Break")
plotshape(enableBreak and (bearFVG and (close < rangeLo or close[1] < rangeLo or close[2] < rangeLo)) and allowEntry and not breakShortConsumed,  title="Break Short", style=shape.triangledown, color=color.new(color.orange, 0), size=size.tiny, location=location.abovebar, text="Break")
plotshape(enableTrap  and breakUpFound   and trapUpRetestedInside   and closeAbove and allowEntry and not trapUpConsumed,  title="Trap Long",  style=shape.circle, color=color.new(color.teal, 0),   size=size.tiny, location=location.belowbar, text="Trap")
plotshape(enableTrap  and breakDownFound and trapDownRetestedInside and closeBelow and allowEntry and not trapDownConsumed,  title="Trap Short", style=shape.circle, color=color.new(color.orange, 0), size=size.tiny, location=location.abovebar, text="Trap")

// -------------------- TP/SL Visuals
plot(showSL and strategy.position_size != 0 ? activeSL : na, title="Stop Loss", color=color.new(color.fuchsia, 0), linewidth=2, style=plot.style_line)
plot(showTP and strategy.position_size != 0 ? activeTP : na, title="Take Profit", color=color.new(color.green, 0), linewidth=2, style=plot.style_line)
plotshape(enableReversal and breakDownFound and bullFVG and closeInside and allowEntry and not revLongConsumed, title="Reversal Long",  style=shape.diamond, color=color.new(color.teal, 0),   size=size.tiny, location=location.belowbar, text="Rev")
plotshape(enableReversal and breakUpFound   and bearFVG and closeInside and allowEntry and not revShortConsumed, title="Reversal Short", style=shape.diamond, color=color.new(color.orange, 0), size=size.tiny, location=location.abovebar, text="Rev")